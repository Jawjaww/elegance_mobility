'use client';

import { useEffect, useRef, useState } from 'react';
import maplibregl from 'maplibre-gl';
import 'maplibre-gl/dist/maplibre-gl.css';
import '@/styles/client-map.css';
import '@/styles/vector-map.css';
import { mapConfig } from '@/config/map';

// Charger la configuration vectorielle optimisée
const vectorStyle = mapConfig.clientVectorStyle;

interface ClientMapProps {
  origin: {lat: number, lon: number} | null;
  destination: {lat: number, lon: number} | null;
  className?: string;
}

export default function ClientConfirmationMap({ origin, destination, className = '' }: ClientMapProps) {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<maplibregl.Map | null>(null);
  const markersRef = useRef<maplibregl.Marker[]>([]);
  const [routeCoordinates, setRouteCoordinates] = useState<[number, number][]>([]);      // Options préconfigurées pour améliorer les performances avec tuiles vectorielles
  const [mapOptions] = useState({
    ...mapConfig.performance,       // Utiliser les paramètres de performance optimisés
    fadeDuration: 0,                // Transitions plus rapides
    localIdeographFontFamily: "'Noto Sans', 'Noto Sans CJK SC', sans-serif", // Police optimisée
    transformRequest: (url: string) => {
      // Priorité aux requêtes de tuiles vectorielles
      return { url };
    }
  });
  
  // Fonction pour calculer l'itinéraire via l'API OSRM avec gestion des erreurs améliorée
  const fetchRoute = async (start: [number, number], end: [number, number]) => {
    try {
      console.log("Récupération de l'itinéraire:", start, end);
      
      // L'API OpenStreetMap Routing Machine (OSRM) attend le format [longitude, latitude]
      const url = `https://router.project-osrm.org/route/v1/driving/${start[0]},${start[1]};${end[0]},${end[1]}?overview=full&geometries=geojson`;
      
      // Tentative directe avec timeout pour éviter les attentes trop longues
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3000);
      
      const response = await fetch(url, { 
        signal: controller.signal,
        cache: 'no-store'
      }).finally(() => clearTimeout(timeoutId));
      
      if (!response.ok) {
        throw new Error("Erreur lors de la récupération de l'itinéraire");
      }
      
      const data = await response.json();
      
      if (data.routes && data.routes.length > 0) {
        // Extraire les coordonnées du trajet
        return data.routes[0].geometry.coordinates;
      } else {
        console.error("Pas d'itinéraire trouvé");
        // Route à vol d'oiseau par défaut
        return [start, end];
      }
    } catch (error) {
      console.error("Erreur lors du calcul de l'itinéraire:", error);
      // Route à vol d'oiseau en cas d'erreur
      return [start, end];
    }
  };

  useEffect(() => {
    if (!mapContainer.current || (!origin && !destination)) return;
    
    // Nettoyer les anciennes instances et forcer la libération des ressources WebGL
    if (map.current) {
      // Récupérer le contexte WebGL avant de supprimer la carte
      const canvas = map.current.getCanvas();
      const gl = canvas.getContext('webgl');
      
      // Supprimer tous les marqueurs
      markersRef.current.forEach(marker => marker.remove());
      
      // Supprimer proprement la carte
      map.current.remove();
      
      // Forcer la libération du contexte WebGL
      if (gl) {
        gl.getExtension('WEBGL_lose_context')?.loseContext();
      }
    }
    
    // Définir le centre et le zoom initiaux
    const centerPoint = origin && destination 
      ? [(origin.lon + destination.lon) / 2, (origin.lat + destination.lat) / 2] 
      : origin 
        ? [origin.lon, origin.lat]
        : destination 
          ? [destination.lon, destination.lat]
          : [2.3488, 48.8534]; // Paris par défaut
    
    // Créer l'instance de carte avec style vectoriel pour meilleures performances
    const mapInstance = new maplibregl.Map({
      container: mapContainer.current,
      // Utilisation du style vectoriel optimisé depuis la configuration
      style: {
        version: 8,
        sources: {
          // Tuiles vectorielles de MapLibre (sans problème CORS)
          'openmaptiles': {
            type: 'vector',
            tiles: [
              // MapLibre Demo Tiles - directement depuis la source, performances optimales
              'https://demotiles.maplibre.org/tiles/{z}/{x}/{y}.pbf'
            ],
            minzoom: 0,
            maxzoom: 14,
            attribution: mapConfig.attribution
          }
        },
        layers: [
          // Fond clair pour client
          {
            id: 'background',
            type: 'background',
            paint: {
              'background-color': '#f8f9fa'
            }
          },
          // Routes principales
          {
            id: 'roads-major',
            type: 'line',
            source: 'openmaptiles',
            'source-layer': 'transportation',
            filter: ['in', 'class', 'trunk', 'primary', 'secondary'],
            paint: {
              'line-color': '#cbd5e1',
              'line-width': 2
            }
          },
          // Routes secondaires
          {
            id: 'roads-minor',
            type: 'line',
            source: 'openmaptiles',
            'source-layer': 'transportation',
            filter: ['in', 'class', 'tertiary', 'minor', 'service'],
            paint: {
              'line-color': '#e2e8f0',
              'line-width': 1
            }
          },
          // Points d'intérêt
          {
            id: 'poi',
            type: 'symbol',
            source: 'openmaptiles',
            'source-layer': 'poi',
            minzoom: 14,
            layout: {
              'icon-image': '{class}_11',
              'text-field': '{name}',
              'text-size': 11,
              'text-optional': true,
              'text-offset': [0, 0.8],
              'visibility': 'visible'
            },
            paint: {
              'text-color': '#334155',
              'text-halo-color': '#ffffff',
              'text-halo-width': 1
            }
          },
          // Bâtiments
          {
            id: 'buildings',
            type: 'fill',
            source: 'openmaptiles',
            'source-layer': 'building',
            paint: {
              'fill-color': '#f1f5f9',
              'fill-opacity': 0.5,
              'fill-outline-color': '#e2e8f0'
            }
          }
        ]
      },
      center: centerPoint as [number, number],
      zoom: 12,
      minZoom: 4,         // Limiter le zoom minimum pour éviter des performances faibles
      ...mapOptions,      // Appliquer les options d'optimisation
      maxZoom: 16,        // Limiter le zoom maximum pour éviter des calculs intensifs
      trackResize: true,  // Suivre les redimensionnements mais limiter la fréquence
      boxZoom: false,     // Désactiver des contrôles peu utilisés
      pitchWithRotate: false
    });
    
    map.current = mapInstance;
    
    // Ajouter les marqueurs une fois que la carte est chargée
    mapInstance.on('load', async () => {
      markersRef.current = [];
      
      // Marqueur d'origine
      if (origin) {
        const el = document.createElement('div');
        el.className = 'client-marker client-marker-departure';
        
        const marker = new maplibregl.Marker(el)
          .setLngLat([origin.lon, origin.lat])
          .addTo(mapInstance);
          
        markersRef.current.push(marker);
      }
      
      // Marqueur de destination
      if (destination) {
        const el = document.createElement('div');
        el.className = 'client-marker client-marker-destination';
        
        const marker = new maplibregl.Marker(el)
          .setLngLat([destination.lon, destination.lat])
          .addTo(mapInstance);
          
        markersRef.current.push(marker);
      }
      
      // Ajouter une ligne pour connecter les points avec un itinéraire
      if (origin && destination) {
        try {
          // Récupérer l'itinéraire
          const coordinates = await fetchRoute(
            [origin.lon, origin.lat],
            [destination.lon, destination.lat]
          );
          
          setRouteCoordinates(coordinates);
          
          // Ajouter la source pour la ligne, en vérifiant si la carte est prête
          try {
            // Vérifier d'abord si la source existe déjà et la supprimer si nécessaire
            let sourceExists = false;
            try {
              sourceExists = Boolean(mapInstance.getSource('route'));
            } catch (e) {
              // La source n'existe pas encore, pas de problème
            }
            
            if (sourceExists) {
              // Si la source existe déjà, on doit d'abord supprimer toutes les couches associées
              try {
                if (mapInstance.getLayer('route-casing')) mapInstance.removeLayer('route-casing');
                if (mapInstance.getLayer('route-line')) mapInstance.removeLayer('route-line');
                mapInstance.removeSource('route');
              } catch (e) {
                console.log("Erreur lors du nettoyage des couches:", e);
              }
            }
            
            // Ajouter la source pour la ligne
            mapInstance.addSource('route', {
              type: 'geojson',
              data: {
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'LineString',
                  coordinates: coordinates
                }
              }
            });
          
            // Ajouter les couches de ligne optimisées pour tuiles vectorielles
            // Contour d'ombrage pour meilleure visibilité
            mapInstance.addLayer({
              id: 'route-casing',
              type: 'line',
              source: 'route',
              layout: {
                'line-join': 'round',
                'line-cap': 'round',
                'visibility': 'visible',
              },
              paint: {
                'line-color': '#1e40af',
                'line-width': 6,
                'line-opacity': 0.4,
                'line-blur': 0.5,
              }
            });
            
            // Ligne principale avec rendu optimisé pour vectorielle
            mapInstance.addLayer({
              id: 'route-line',
              type: 'line',
              source: 'route',
              layout: {
                'line-join': 'round',
                'line-cap': 'round',
                'visibility': 'visible',
              },
              paint: {
                'line-color': '#3b82f6',
                'line-width': 4,
                'line-opacity': 0.9,
                'line-blur': 0, // Améliore la netteté des lignes vectorielles
                'line-gap-width': 0 // Optimise le rendu
              }
            });
            
            // Ajuster la vue pour montrer l'itinéraire complet
            if (coordinates.length > 0) {
              const bounds = new maplibregl.LngLatBounds();
              
              coordinates.forEach((coord: [number, number]) => {
                bounds.extend(coord as maplibregl.LngLatLike);
              });
              
              mapInstance.fitBounds(bounds, {
                padding: 40,
                maxZoom: 15
              });
            }
          } catch (error) {
            console.error("Erreur lors de l'affichage de l'itinéraire:", error);
            
            // En cas d'échec, afficher une ligne droite simple
            mapInstance.addSource('route', {
              type: 'geojson',
              data: {
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'LineString',
                  coordinates: [
                    [origin.lon, origin.lat],
                    [destination.lon, destination.lat]
                  ]
                }
              }
            });
            
            mapInstance.addLayer({
              id: 'route-line',
              type: 'line',
              source: 'route',
              layout: {
                'line-join': 'round',
                'line-cap': 'round'
              },
              paint: {
                'line-color': '#4a89dc',
                'line-width': 3,
                'line-opacity': 0.7
              }
            });
            
            // Ajuster la vue pour montrer les deux points
            const bounds = new maplibregl.LngLatBounds()
              .extend([origin.lon, origin.lat])
              .extend([destination.lon, destination.lat]);
              
            mapInstance.fitBounds(bounds, {
              padding: 40,
              maxZoom: 15
            });
          }
        } catch (e) {
          console.error("Erreur critique lors de l'affichage de l'itinéraire:", e);
        }
      }
      
      // Ajouter les contrôles minimalistes avec un léger délai pour éviter les problèmes de performance
      setTimeout(() => {
        if (map.current) {
          map.current.addControl(
            new maplibregl.NavigationControl({
              showCompass: false,
              visualizePitch: false
            }),
            'bottom-right'
          );
        }
      }, 500);
    });
    
    return () => {
      if (map.current) {
        // Récupérer le contexte WebGL avant de supprimer la carte
        const canvas = map.current.getCanvas();
        const gl = canvas.getContext('webgl');
        
        // Supprimer tous les marqueurs
        markersRef.current.forEach(marker => marker.remove());
        
        // Supprimer proprement la carte
        map.current.remove();
        map.current = null;
        
        // Forcer la libération du contexte WebGL
        if (gl) {
          gl.getExtension('WEBGL_lose_context')?.loseContext();
        }
        
        // Nettoyage supplémentaire des éléments orphelins (après un court délai)
        setTimeout(() => {
          document.querySelectorAll('.maplibregl-canvas-container:not(:has(canvas))').forEach(el => {
            el.parentElement?.removeChild(el);
          });
        }, 100);
      }
    };
  }, [origin, destination]);
  
  return (
    <div
      ref={mapContainer}
      className={`client-map-confirmation client-portal-map ${className}`}
      style={{ visibility: 'visible', display: 'block' }}
    />
  );
}
